<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/python/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/python/"/>
  <updated>2019-02-05T01:05:32-08:00</updated>
  <id>http://tdongsi.github.io/python/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Python Pt. 6: Robust Programs]]></title>
    <link href="http://tdongsi.github.io/python/blog/2018/12/16/effective-python-part-6/"/>
    <updated>2018-12-16T17:58:58-08:00</updated>
    <id>http://tdongsi.github.io/python/blog/2018/12/16/effective-python-part-6</id>
    <content type="html"><![CDATA[<p>This post corresponds to Lesson 6 &ldquo;Making Programs Robust&rdquo; of <a href="https://www.safaribooksonline.com/videos/effective-python/9780134175249">&ldquo;Effective Python&rdquo; course</a>.</p>

<p>NOTE: While the book is about Python 3, my blog checks out its application in Python 2.</p>

<!--more-->


<h3>Item 28: Use virtualenv</h3>

<p>Use <code>pip</code> commands for virtual environment management.</p>

<pre><code class="plain">
$ pip show flask
Name: Flask
Version: 1.0.2
Summary: A simple framework for building complex web applications.
Home-page: https://www.palletsprojects.com/p/flask/
Author: Armin Ronacher
Author-email: armin.ronacher@active-4.com
License: BSD
Location: /Users/tdongsi/Matrix/python/venv/lib/python2.7/site-packages
Requires: Werkzeug, click, Jinja2, itsdangerous
Required-by:

$ pip install --upgrade Jinja2
Requirement already up-to-date: Jinja2 in ./venv/lib/python2.7/site-packages (2.10)
Requirement already satisfied, skipping upgrade: MarkupSafe&gt;=0.23 in ./venv/lib/python2.7/site-packages (from Jinja2) (1.1.0)

$ pip list
Package                  Version
------------------------ ----------
alabaster                0.7.12
Babel                    2.6.0
certifi                  2018.11.29
chardet                  3.0.4
Click                    7.0
...

$ pip freeze
alabaster==0.7.12
Babel==2.6.0
certifi==2018.11.29
chardet==3.0.4
Click==7.0
...

$ pip freeze &gt; requirements.txt

# In another virtualenv
$ pip install -r requirements.txt
</code></pre>

<p>Set up and use virtual environment in Python 2.</p>

<pre><code class="plain">
# Create new virtual env
$ virtualenv venv
New python executable in /Users/tdongsi/Matrix/python/venv/bin/python
Installing setuptools, pip, wheel...
done.

# Activate new virual env
$ source venv/bin/activate

$ deactivate
</code></pre>

<h4>Python 3</h4>

<p>The difference in Python 3 is the dedicated command <code>pyvenv</code> and no separate installation of <code>virtualenv</code> is required.</p>

<pre><code class="plain virtualenv in Python 3">$ pyvenv -h

# Create new virtual env
$ pyvenv myproject

# Activate new virual env
$ source myproject/bin/activate

$ deactivate
</code></pre>

<h3>Item 29: Tests with unittest</h3>

<p>Tests are even more important in Python (than Java) since it is a dynamic language.
<code>unittest</code> module can be used for both unit tests (isolated tests) and functional/integration tests (verifying interactions).</p>

<pre><code class="python unittest examples">from unittest import TestCase

class ExampleTest(TestCase):

    def setUp(self):
        print('Setup')

    def tearDown(self):
        print('Teardown')

    def test_a(self):
        print('a')

    def test_b(self):
        print('b')


if __name__ == '__main__':
    unittest.main()
</code></pre>

<h3>Item 30: Debugging with <code>pdb</code></h3>

<pre><code class="python Use debugger"># Code before
import pdb; pdb.set_trace()
# Code after
</code></pre>

<p>A few debugger commands when you are already in the debugger:</p>

<pre><code class="plain">next
step
locals()
bt  # back trace
up
down
</code></pre>

<p>The Python debugger <code>pdb</code> is very similar to C debugger in Linux.
However, you are probably better off with debugger in proper IDEs such as PyCharm with better visualization.</p>

<h3>Iten 31: Profile before optimizing</h3>

<p>In summary, how to do CPU profiling in Python.</p>

<p>Dynamic nature of Python programs can lead to surprising performance impact.
Profiling is easy to do in Python with built-in modules, as shown below, and allows us to focus on measurable sources of performance bottlenecks.</p>

<pre><code class="python Profiling in Python">from cProfile import Profile
from pstats import Stats

profiler = Profile()
# profiler.runcall(insertion_sort, data)
profiler.runcall(lambda: insertion_sort(data))

stats = Stats(profiler)
stats.strip_dirs()
stats.sort_stats('cumulative')
stats.print_stats()
</code></pre>

<pre><code class="plain Profiler output">         20003 function calls in 0.791 seconds

   Ordered by: cumulative time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.791    0.791 item31.py:27(&lt;lambda&gt;)
        1    0.002    0.002    0.791    0.791 item31.py:7(insertion_sort)
    10000    0.780    0.000    0.789    0.000 item31.py:14(insert_value)
     9989    0.010    0.000    0.010    0.000 {method 'insert' of 'list' objects}
       11    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
</code></pre>

<p>Another print method <code>stats.print_callers()</code> can reorganize the same information in a different way.</p>

<pre><code class="plain">   Ordered by: cumulative time

Function                                          was called by...
                                                      ncalls  tottime  cumtime
item31.py:25(&lt;lambda&gt;)                            &lt;-
item31.py:8(insertion_sort)                       &lt;-       1    0.002    0.023  item31.py:25(&lt;lambda&gt;)
item31.py:15(insert_value)                        &lt;-   10000    0.004    0.021  item31.py:8(insertion_sort)
{method 'insert' of 'list' objects}               &lt;-   10000    0.011    0.011  item31.py:15(insert_value)
{_bisect.bisect_left}                             &lt;-   10000    0.006    0.006  item31.py:15(insert_value)
{method 'disable' of '_lsprof.Profiler' objects}  &lt;-
</code></pre>

<p>More details can be found in <a href="https://docs.python.org/2/library/profile.html">Python documentation</a>.</p>

<h3>Item 32: Use tracemalloc to undertand memory usage and leaks</h3>

<p>In summary, this item is about how to do memory profiling in Python.</p>

<p>Python has automatic garbage collection: reference counting and cycle detection for looping references.
Despite that, memory leaks still happen and it&rsquo;s hard in practice to figure out why references are held.</p>

<pre><code class="python gc module">import gc

found_objects = gc.get_objects()
print('%d objects before' % len(found_objects))

import waste_memory
x = waste_memory.run()

found_objects = gc.get_objects()
print('%d objects after' % len(found_objects))
</code></pre>

<p><code>gc</code> module allows you to interact with garbage collectors and take a look into how many objects created, as shown above.
However, such information is usually not enough to figure out what went wrong: objects of the same class can be created in various ways.
You need more information to figure out where the allocation and the memory leak happens.</p>

<p>In Python 3, we have <code>tracemalloc</code> module that allows comparing between two memory snapshots and trace back to the code lines where such memory allocations happen.
See <a href="https://pytracemalloc.readthedocs.io/examples.html">more examples</a>.
For Python 2.7, it is not part of the Standard Library.
Therefore, we have to patch and compile Python 2.7 to use the 3rd party <code>pytracemalloc</code> module.
The instructions to do it can be found in <a href="http://carsonip.me/posts/debugging-memory-usage-python-tracemalloc/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Python Pt. 5: Concurrency and Parallelism]]></title>
    <link href="http://tdongsi.github.io/python/blog/2018/08/18/effective-python-pt-5-concurrency-and-parallelism/"/>
    <updated>2018-08-18T16:24:30-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2018/08/18/effective-python-pt-5-concurrency-and-parallelism</id>
    <content type="html"><![CDATA[<p>This post corresponds to Lesson 5 &ldquo;Concurrency and Parallelism&rdquo; of <a href="https://www.safaribooksonline.com/videos/effective-python/9780134175249">&ldquo;Effective Python&rdquo; course</a>.</p>

<!--more-->


<h3>Item 23: Use subprocess to manage child processes</h3>

<pre><code class="python Typical usage of subprocess module">import subprocess

proc = subprocess.Popen(
    ['echo', 'Hello World'],
    stdout=subprocess.PIPE
)
out, err = proc.communicate()
print(out.decode('utf-8'))
</code></pre>

<pre><code class="python Simple forking example">proc = subprocess.Popen(['sleep', '0.3'])
while proc.poll() is None:
    print('Working...')
    # Time consuming process
    time.sleep(0.2)

print('Exit status: %d' % proc.poll())
</code></pre>

<p>In the forking example above, note that <code>proce.poll()</code> is used to check for and obtain the status of the child process.</p>

<pre><code class="python Parallelism wtih subprocess">def run_sleep(period):
    proc = subprocess.Popen(['sleep', str(period)])
    return proc


start = time.time()
procs = []
for _ in range(10):
    proc = run_sleep(0.3)
    procs.append(proc)

for proc in procs:
    proc.communicate()

end = time.time()
print('Takes %f seconds' % (end - start))
</code></pre>

<p>In the parallisim example above, the time it takes is approximately 0.3 seconds, no matter how many processes you create.</p>

<pre><code class="python Piping data from Python data to subprocess"># You can pipe data from Python program to subprocess
# In this way, you can call other programs to run in parallel with Python process.
# Run sub-processes on multiple CPUs.
def run_openssl(data):
    """A computing-intensive method, best for running separately on separate CPUs."""
    env = os.environ.copy()
    env['password'] = b'asdf'
    proc = subprocess.Popen(
        ['openssl', 'enc', '-des3', '-pass', 'env:password'],
        env=env,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE
    )
    proc.stdin.write(data)
    proc.stdin.flush()
    return proc

procs = []
for _ in range(5):
    data = os.urandom(100)
    proc = run_openssl(data)
    procs.append(proc)

for proc in procs:
    out, _ = proc.communicate()
    print(out)
</code></pre>

<p>Note that in this piping example above, you can use <code>os.environ.copy</code> to shield current process&rsquo;s environment from modifications of its variables.
You can use the new copy of environment by specifying <code>env=my_env</code> in <code>Popen</code> constructor.
In addition, you can use the environment variable as parameters in the <code>Popen</code> command by using <code>env:password</code>.
To pipe data from Python into the subprocess, you need to set <code>stdin=subprocess.PIPE</code> and transfer data by using <code>proc.stdin.write(data)</code>.</p>

<pre><code class="python Subprocess timeout in Python 3"># Python 3 way
proc = subprocess.Popen(['sleep', '10'])
try:
    proc.communicate(timeout=0.1)
except subprocess.TimeoutExpired:
    proc.terminate()
    proc.wait()

print('Exit status', proc.poll())
</code></pre>

<p>It&rsquo;s not available in Python 2, and if you want to reproduce its functionality in Python 2, you actually have to use the <code>select</code> module and poll the input and output file descriptors of the subprocess.
It is a little bit more complicated and it&rsquo;s hard to get right.</p>

<pre><code class="python Stop-gap alternative in Python 2">class Command(object):
    """ Stop-gap alternative for subprocess's timeout in Python 3.
    Based on https://stackoverflow.com/questions/1191374/using-module-subprocess-with-timeout
    """

    def __init__(self, process):
        self.process = process

    def run(self, timeout):
        def target():
            self.process.communicate()

        thread = threading.Thread(target=target)
        thread.start()

        thread.join(timeout)
        if thread.is_alive():
            print 'Terminating process'
            self.process.terminate()
            thread.join()

        print(self.process.returncode)

proc = subprocess.Popen(['sleep', '2'])
command = Command(proc)
command.run(timeout=3)

# NOTE: the following will not work since the subprocess already ran.
# command = Command(proc)
command = Command(subprocess.Popen(['sleep', '2']))
command.run(timeout=1)
</code></pre>

<h3>Item 24: Use threads for blocking I/O, NOT for parallelism</h3>

<p>Python has the GIL, or Global Interpreter Lock.
It means that only one Python thread will ever actually run at a time.
A common mistake is to use threads to speed up a computation-intensive program in Python.
You will be usually disappointed and end up with similar, if not worse, performance.
In other words, you might find that your complicated parallel version will have similar performance as the serial one.</p>

<p>In Python, threads are good for two main use cases.
The first use case is, if you want something looks running simultaneously (concurrency).
A common example is to respond to user inputs while doing network I/O.
In this case, the threads will cooperate with each other to obtain GIL fairly.
The second use case for threads in Python is for IO-intensive applications such as those with lots of (blocking) network, system calls.
A common example is to use threads to query multiple REST endpoints concurrently.
The following example illustrate such use case:</p>

<pre><code class="python Use Python threads for network I/O">import threading
import requests
import time

def get_response(url):
    r = requests.get(url)
    return r.status_code, r.text

class RequestThread(threading.Thread):

    def __init__(self, url):
        super(RequestThread, self).__init__()
        self._url = url

    def run(self):
        self.output = get_response(self._url)

urls = ['https://www.google.com',
        'https://www.facebook.com',
        'https://www.apple.com',
        'https://www.netflix.com',
        'https://www.salesforce.com',
        'https://www.intuit.com',
        'https://www.amazon.com',
        'https://www.uber.com',
        'https://www.lyft.com']

threads = []
for url in urls:
    thread = RequestThread(url)
    thread.start()
    threads.append(thread)

for thread in threads:
    thread.join()
</code></pre>

<p>TODO: Explain GIL and under the cover, <code>request</code> release the control of GIL.</p>

<p>TODO: mistake</p>

<p>TODO: Note about how to call constructor.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 3 Quick Recap]]></title>
    <link href="http://tdongsi.github.io/python/blog/2017/08/13/python-3-quick-recap/"/>
    <updated>2017-08-13T23:49:57-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2017/08/13/python-3-quick-recap</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Requests Cookbook]]></title>
    <link href="http://tdongsi.github.io/python/blog/2017/08/06/requests-cookbook/"/>
    <updated>2017-08-06T23:17:25-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2017/08/06/requests-cookbook</id>
    <content type="html"><![CDATA[<p><code>requests</code> module is a simple HTTP client library in Python.</p>

<!-- more -->


<h3>Example: BART parking</h3>

<p>The problem is discussed <a href="http://tdongsi.github.io/blog/2016/10/30/automated-downloading-bart-parking-permits/">here</a>.
The <code>requests</code>&rsquo;s code snippets can be found <a href="https://github.com/tdongsi/bart-parking/blob/develop/python/bart.py">here</a>.</p>

<p>Featuring:</p>

<ul>
<li>Login with CSRF protection (with POST)</li>
<li>Cookie retrieval and usage</li>
<li>Binary download and saved to file.</li>
</ul>


<pre><code class="python Different payload for POST"># POST /bart/users/login/ HTTP/1.1
# Content-Type: application/x-www-form-urlencoded
HEADERS = {"Referer": "https://www.select-a-spot.com/bart/"}
params = {"username": username,
            "password": password,
            "csrfmiddlewaretoken": r.cookies["csrftoken"],
            "login": "Login"}
r = s.post("https://www.select-a-spot.com/bart/users/login/", headers=HEADERS, data=params, allow_redirects=False)

# POST /kafka/topic HTTP/1.1
# Content-Type: application/json
my_data = {'name': IOT_TOPIC, 'type': '/types/com.prod.emp'}
my_header = {'Accept': 'application/json', 'Content-Type': 'application/json'}

logger.info('POST: %s', TOPIC_ENDPOINT)
r = s.post(TOPIC_ENDPOINT, headers=my_header, data=json.dumps(my_data), cert=KAFKA_CERTS)
</code></pre>

<p>Note that <code>json.dumps</code> is required for POST-ing JSON data. The typical service response:</p>

<pre><code class="plain Error message">"exception":"org.springframework.http.converter.HttpMessageNotReadableException","message":"Bad Request"
</code></pre>

<h3>SSL authentication</h3>

<p>You can specify your certificate and private key in <code>cert=(my_cert, my_key)</code> as a method parameter.
The certificate authority can be optionally specified (<code>s.verify = MY_CA</code>) or not (<code>s.verify = False</code>).</p>

<pre><code class="python SSL authentication">def test_kafka(my_cert, my_key):
    """ Top level function to test_kafka.

    :param my_cert: path to certificate.
    :param my_key: path to private key corresponding to the certificate.
    :return:
    """

    ZOOKEEPER_EP = 'https://kafka-prd.corp.net:9090'
    IOT_NAMESPACE = 'test'
    MY_CA = 'download/ca.crt'

    s = requests.Session()
    s.verify = MY_CA

    def test_namespace():
        """ Test querying kafka namespace.

        Basically: curl -k -E ./kafka.p12:password "https://kafka.prd:9090/namespaces/test"
        """
        NAMESPACE_PATH = '/namespaces'
        endpoint = ZOOKEEPER_EP + NAMESPACE_PATH + '/' + IOT_NAMESPACE

        logger.info('GET: %s', endpoint)
        r = s.get(endpoint, cert=(my_cert, my_key))

        logger.debug("Response: %s", r.text)
        data = json.loads(r.text)
        # print json.dumps(data, indent=4)
        # Print namespace
        logger.info("ID: %s", data['id'])
        pass

    test_namespace()
</code></pre>

<h3>Unit testing</h3>

<p>You can do unit testing by using <code>requests-mock</code> package.</p>

<pre><code class="plain Installation"># Only required for Python 2. Mock is part of Python 3.
pip install -U mock

pip install requests-mock
</code></pre>

<pre><code class="python Example of mocking">    @requests_mock.mock()    
    def test_get_env_status(self, m):
        #Test status code 400 returns False
        m.get(self.status_endpoint, status_code=404)
        with mock.patch.dict(os.environ,{'username':'mytempuser', 'password':'temppass'}):
            self.assertEquals(FlowSnakeEnvironment.get_env_status(self.fsenv_name), None)
</code></pre>

<h4>References</h4>

<ul>
<li><a href="https://media.readthedocs.org/pdf/requests-mock/latest/requests-mock.pdf">PDF doc</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tutorial: Protocols]]></title>
    <link href="http://tdongsi.github.io/python/blog/2016/09/05/tutorial-protocols/"/>
    <updated>2016-09-05T23:50:24-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2016/09/05/tutorial-protocols</id>
    <content type="html"><![CDATA[<p>Python uses &ldquo;duck typing&rdquo;.
It does not have interfaces like Java to enforce certain behaviors:
<code>Iterable</code> iterface means that you can iterate an object of that class in a <code>for each</code> loop.
In Python, to do that, you have to override magic functions like <code>__iter__</code> to achieve some behaviors.
Each behavior is called &ldquo;protocol&rdquo; in this post since some involves overriding multiple magic funtions.</p>

<!-- Reference:
Evernote: "OOP in Python"
-->




<!--more-->


<h3>Iterator</h3>

<p>Here, <code>__iter__</code> just returns self, an object that has the function next(), which (when called) either returns a value or raises a StopIteration exception.
We’ve actually already met several iterators in disguise; in particular, <code>enumerate</code> is an iterator.
To drive home the point, here’s a simple reimplementation of <code>enumerate</code>:</p>

<pre><code class="python Implement enumerator() as iterator">&gt;&gt;&gt; class my_enumerate:
...   def __init__(self, some_iter):
...      self.some_iter = iter(some_iter)
...      self.count = -1
...
...   def __iter__(self):
...      return self
...
...   def next(self):
...      val = self.some_iter.next()
...      self.count += 1
...      return self.count, val
&gt;&gt;&gt; for n, val in my_enumerate(['a', 'b', 'c']):
...   print n, val
0 a
1 b
2 c
</code></pre>

<h4>Generator and Iterator protocol</h4>

<p>It is also much easier to write routines like enumerate as a generator than as an iterator:</p>

<pre><code class="python Implement enumerate() using generator">&gt;&gt;&gt; def gen_enumerate(some_iter):
...   count = 0
...   for val in some_iter:
...      yield count, val
...      count += 1
</code></pre>

<p>But you can do things with generators that you couldn’t do with finite lists.
Consider two full implementation of Eratosthenes’ Sieve for finding prime numbers.
Full discussion is <a href="http://intermediate-and-advanced-software-carpentry.readthedocs.io/en/latest/idiomatic-python.html">here</a>.
Most of these are from &ldquo;Python tutorial&rdquo;.</p>

<h3>Container</h3>
]]></content>
  </entry>
  
</feed>
