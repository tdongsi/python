<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/python/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/python/"/>
  <updated>2019-04-01T00:05:37-07:00</updated>
  <id>http://tdongsi.github.io/python/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Mock Recipes]]></title>
    <link href="http://tdongsi.github.io/python/blog/2019/03/31/python-mock-recipes/"/>
    <updated>2019-03-31T22:49:05-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2019/03/31/python-mock-recipes</id>
    <content type="html"><![CDATA[<p>Recipes for mocking with <code>unittest.mock</code> module when writing unit tests in Python.</p>

<!--more-->


<h3>Mock simple HTTP responses</h3>

<p>When testing REST clients that use <code>requests</code> module, it is better to use this utility method to construct mock HTTP responses.</p>

<pre><code class="python Utility method to create mock response">def create_mock_response(status=200, content="{}"):
    """ Create mock HTTTP responses for "requests" module.

    :param status: override Response.status_code. Example: 200
    :param content: override Response.text and Response.content.
    :return: mock response object
    """
    mock_response = mock.Mock()
    mock_response.status_code = status
    mock_response.text = content
    mock_response.content = content

    return mock_response
</code></pre>

<p>By mocking HTTP (usually GET) responses, you can validate the REST client&rsquo;s behavior for a certain response.
This is useful as we can reproduce exceptional, failure scenarios such as those with 4xx error codes.</p>

<pre><code class="python Example test">    @mock.patch('requests.get')
    def test_get_deployments_429(self, mock_get):
        """ Failure case. """
        # Mock response
        mock_text = u'{"reponse": "Slow down."}'
        mock_response = base.create_mock_response(status=429, content=mock_text)

        mock_get.return_value = mock_response

        # REST client's function that sends GET request here
        # ...
        with self.assertRaises(ResponseRateException) as bg:
            method_under_test(**arguments)

        self.assertTrue('request not accepted' in bg.exception.message)

        pass
</code></pre>

<h3>Redirect <code>stdout</code> output to variable for validation</h3>

<p>Some legacy codes tend to spam <code>print</code> statements and you probably need to check if the output is correct.
In that case, we can redirect <code>print</code>&rsquo;s output to some variable and assert the value of that string variable.</p>

<p>There is a popular but complex way to redirect <code>stdout</code> to a string variable, thanks to being the <a href="https://stackoverflow.com/questions/1218933/can-i-redirect-the-stdout-in-python-into-some-sort-of-string-buffer">top and accepted answer on Stackoverflow</a>.</p>

<pre><code class="python Complex way">from StringIO import StringIO  # Python2
from io import StringIO  # Python3

 import sys

# Store the reference for restoring

old_stdout = sys.stdout

# This variable will store everything that is sent to the standard output
sys.stdout = StringIO()

call_method_under_test()

# Redirect again the std output to screen
sys.stdout = old_stdout

# Then, get the stdout like a string
result_string = result.getvalue()

assert(expected_output, result_string)
</code></pre>

<p>In the context of unit testing, to ensure that all unit tests are indepedenent, you have to set and reset <code>sys.stdout</code> in each unit test separately.
As a result, it is very inconvenient when you may have hundreds of unit tests and only tens of them need that output redirection for validation.
Instead, <code>mock</code> module makes it easy as follows:</p>

<pre><code class="python Mock print statements">        # Mock sys.stdout to redirect "print"'s output to a variable mock_stdout
        with mock.patch('sys.stdout', new_callable=StringIO) as mock_stdout:
            method_under_test(**arguments)
            # result_string is what method_under_test print out
            result_string = mock_stdout.getvalue()
            # Compare two objects from two JSON strings
            self.assertEqual(expected_output, result_string)
</code></pre>

<h3>Skip waiting when testing</h3>

<p>Many methods under test need to sleep while waiting for some external factor before proceeding to its next stage.
If the external components (e.g., HTTP responses) are already mocked out, such waiting maybe not necessary and we&rsquo;d like to skip the waiting parts.
Using <code>mock.patch</code>, it is easy to mock out <code>time.sleep</code> to skip such waiting parts.</p>

<pre><code class="python Skip waiting">        # Mock time.sleep to skip sleeping
        with mock.patch('time.sleep', return_value=None):
            # Mock sys.stdout to redirect "print" statement's output to a variable mock_stdout
            with mock.patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                execute_long_running(0.25, {})

            # result_string is what _execute_canary_deployment prints out
            result_string = mock_stdout.getvalue()
            self.assertTrue('expected string' in result_string)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Python Pt. 6: Robust Programs]]></title>
    <link href="http://tdongsi.github.io/python/blog/2018/12/16/effective-python-part-6/"/>
    <updated>2018-12-16T17:58:58-08:00</updated>
    <id>http://tdongsi.github.io/python/blog/2018/12/16/effective-python-part-6</id>
    <content type="html"><![CDATA[<p>This post corresponds to Lesson 6 &ldquo;Making Programs Robust&rdquo; of <a href="https://www.safaribooksonline.com/videos/effective-python/9780134175249">&ldquo;Effective Python&rdquo; course</a>.</p>

<p>NOTE: While the book is about Python 3, my blog checks out its application in Python 2.</p>

<!--more-->


<h3>Item 28: Use virtualenv</h3>

<p>Use <code>pip</code> commands for virtual environment management.</p>

<pre><code class="plain">
$ pip show flask
Name: Flask
Version: 1.0.2
Summary: A simple framework for building complex web applications.
Home-page: https://www.palletsprojects.com/p/flask/
Author: Armin Ronacher
Author-email: armin.ronacher@active-4.com
License: BSD
Location: /Users/tdongsi/Matrix/python/venv/lib/python2.7/site-packages
Requires: Werkzeug, click, Jinja2, itsdangerous
Required-by:

$ pip install --upgrade Jinja2
Requirement already up-to-date: Jinja2 in ./venv/lib/python2.7/site-packages (2.10)
Requirement already satisfied, skipping upgrade: MarkupSafe&gt;=0.23 in ./venv/lib/python2.7/site-packages (from Jinja2) (1.1.0)

$ pip list
Package                  Version
------------------------ ----------
alabaster                0.7.12
Babel                    2.6.0
certifi                  2018.11.29
chardet                  3.0.4
Click                    7.0
...

$ pip freeze
alabaster==0.7.12
Babel==2.6.0
certifi==2018.11.29
chardet==3.0.4
Click==7.0
...

$ pip freeze &gt; requirements.txt

# In another virtualenv
$ pip install -r requirements.txt
</code></pre>

<p>Set up and use virtual environment in Python 2.</p>

<pre><code class="plain">
# Create new virtual env
$ virtualenv venv
New python executable in /Users/tdongsi/Matrix/python/venv/bin/python
Installing setuptools, pip, wheel...
done.

# Activate new virual env
$ source venv/bin/activate

$ deactivate
</code></pre>

<h4>Python 3</h4>

<p>The difference in Python 3 is the dedicated command <code>pyvenv</code> and no separate installation of <code>virtualenv</code> is required.</p>

<pre><code class="plain virtualenv in Python 3">$ pyvenv -h

# Create new virtual env
$ pyvenv myproject

# Activate new virual env
$ source myproject/bin/activate

$ deactivate
</code></pre>

<h3>Item 29: Tests with unittest</h3>

<p>Tests are even more important in Python (than Java) since it is a dynamic language.
<code>unittest</code> module can be used for both unit tests (isolated tests) and functional/integration tests (verifying interactions).</p>

<pre><code class="python unittest examples">from unittest import TestCase

class ExampleTest(TestCase):

    def setUp(self):
        print('Setup')

    def tearDown(self):
        print('Teardown')

    def test_a(self):
        print('a')

    def test_b(self):
        print('b')


if __name__ == '__main__':
    unittest.main()
</code></pre>

<h3>Item 30: Debugging with <code>pdb</code></h3>

<pre><code class="python Use debugger"># Code before
import pdb; pdb.set_trace()
# Code after
</code></pre>

<p>A few debugger commands when you are already in the debugger:</p>

<pre><code class="plain">next
step
locals()
bt  # back trace
up
down
</code></pre>

<p>The Python debugger <code>pdb</code> is very similar to C debugger in Linux.
However, you are probably better off with debugger in proper IDEs such as PyCharm with better visualization.</p>

<h3>Iten 31: Profile before optimizing</h3>

<p>In summary, how to do CPU profiling in Python.</p>

<p>Dynamic nature of Python programs can lead to surprising performance impact.
Profiling is easy to do in Python with built-in modules, as shown below, and allows us to focus on measurable sources of performance bottlenecks.</p>

<pre><code class="python Profiling in Python">from cProfile import Profile
from pstats import Stats

profiler = Profile()
# profiler.runcall(insertion_sort, data)
profiler.runcall(lambda: insertion_sort(data))

stats = Stats(profiler)
stats.strip_dirs()
stats.sort_stats('cumulative')
stats.print_stats()
</code></pre>

<pre><code class="plain Profiler output">         20003 function calls in 0.791 seconds

   Ordered by: cumulative time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.791    0.791 item31.py:27(&lt;lambda&gt;)
        1    0.002    0.002    0.791    0.791 item31.py:7(insertion_sort)
    10000    0.780    0.000    0.789    0.000 item31.py:14(insert_value)
     9989    0.010    0.000    0.010    0.000 {method 'insert' of 'list' objects}
       11    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
</code></pre>

<p>Another print method <code>stats.print_callers()</code> can reorganize the same information in a different way.</p>

<pre><code class="plain">   Ordered by: cumulative time

Function                                          was called by...
                                                      ncalls  tottime  cumtime
item31.py:25(&lt;lambda&gt;)                            &lt;-
item31.py:8(insertion_sort)                       &lt;-       1    0.002    0.023  item31.py:25(&lt;lambda&gt;)
item31.py:15(insert_value)                        &lt;-   10000    0.004    0.021  item31.py:8(insertion_sort)
{method 'insert' of 'list' objects}               &lt;-   10000    0.011    0.011  item31.py:15(insert_value)
{_bisect.bisect_left}                             &lt;-   10000    0.006    0.006  item31.py:15(insert_value)
{method 'disable' of '_lsprof.Profiler' objects}  &lt;-
</code></pre>

<p>More details can be found in <a href="https://docs.python.org/2/library/profile.html">Python documentation</a>.</p>

<h3>Item 32: Use tracemalloc to undertand memory usage and leaks</h3>

<p>In summary, this item is about how to do memory profiling in Python.</p>

<p>Python has automatic garbage collection: reference counting and cycle detection for looping references.
Despite that, memory leaks still happen and it&rsquo;s hard in practice to figure out why references are held.</p>

<pre><code class="python gc module">import gc

found_objects = gc.get_objects()
print('%d objects before' % len(found_objects))

import waste_memory
x = waste_memory.run()

found_objects = gc.get_objects()
print('%d objects after' % len(found_objects))
</code></pre>

<p><code>gc</code> module allows you to interact with garbage collectors and take a look into how many objects created, as shown above.
However, such information is usually not enough to figure out what went wrong: objects of the same class can be created in various ways.
You need more information to figure out where the allocation and the memory leak happens.</p>

<p>In Python 3, we have <code>tracemalloc</code> module that allows comparing between two memory snapshots and trace back to the code lines where such memory allocations happen.
See <a href="https://pytracemalloc.readthedocs.io/examples.html">more examples</a>.
For Python 2.7, it is not part of the Standard Library.
Therefore, we have to patch and compile Python 2.7 to use the 3rd party <code>pytracemalloc</code> module.
The instructions to do it can be found in <a href="http://carsonip.me/posts/debugging-memory-usage-python-tracemalloc/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Python Pt. 5: Concurrency and Parallelism]]></title>
    <link href="http://tdongsi.github.io/python/blog/2018/08/18/effective-python-pt-5-concurrency-and-parallelism/"/>
    <updated>2018-08-18T16:24:30-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2018/08/18/effective-python-pt-5-concurrency-and-parallelism</id>
    <content type="html"><![CDATA[<p>This post corresponds to Lesson 5 &ldquo;Concurrency and Parallelism&rdquo; of <a href="https://www.safaribooksonline.com/videos/effective-python/9780134175249">&ldquo;Effective Python&rdquo; course</a>.</p>

<!--more-->


<h3>Item 23: Use subprocess to manage child processes</h3>

<pre><code class="python Typical usage of subprocess module">import subprocess

proc = subprocess.Popen(
    ['echo', 'Hello World'],
    stdout=subprocess.PIPE
)
out, err = proc.communicate()
print(out.decode('utf-8'))
</code></pre>

<pre><code class="python Simple forking example">proc = subprocess.Popen(['sleep', '0.3'])
while proc.poll() is None:
    print('Working...')
    # Time consuming process
    time.sleep(0.2)

print('Exit status: %d' % proc.poll())
</code></pre>

<p>In the forking example above, note that <code>proce.poll()</code> is used to check for and obtain the status of the child process.</p>

<pre><code class="python Parallelism wtih subprocess">def run_sleep(period):
    proc = subprocess.Popen(['sleep', str(period)])
    return proc


start = time.time()
procs = []
for _ in range(10):
    proc = run_sleep(0.3)
    procs.append(proc)

for proc in procs:
    proc.communicate()

end = time.time()
print('Takes %f seconds' % (end - start))
</code></pre>

<p>In the parallisim example above, the time it takes is approximately 0.3 seconds, no matter how many processes you create.</p>

<pre><code class="python Piping data from Python data to subprocess"># You can pipe data from Python program to subprocess
# In this way, you can call other programs to run in parallel with Python process.
# Run sub-processes on multiple CPUs.
def run_openssl(data):
    """A computing-intensive method, best for running separately on separate CPUs."""
    env = os.environ.copy()
    env['password'] = b'asdf'
    proc = subprocess.Popen(
        ['openssl', 'enc', '-des3', '-pass', 'env:password'],
        env=env,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE
    )
    proc.stdin.write(data)
    proc.stdin.flush()
    return proc

procs = []
for _ in range(5):
    data = os.urandom(100)
    proc = run_openssl(data)
    procs.append(proc)

for proc in procs:
    out, _ = proc.communicate()
    print(out)
</code></pre>

<p>Note that in this piping example above, you can use <code>os.environ.copy</code> to shield current process&rsquo;s environment from modifications of its variables.
You can use the new copy of environment by specifying <code>env=my_env</code> in <code>Popen</code> constructor.
In addition, you can use the environment variable as parameters in the <code>Popen</code> command by using <code>env:password</code>.
To pipe data from Python into the subprocess, you need to set <code>stdin=subprocess.PIPE</code> and transfer data by using <code>proc.stdin.write(data)</code>.</p>

<pre><code class="python Subprocess timeout in Python 3"># Python 3 way
proc = subprocess.Popen(['sleep', '10'])
try:
    proc.communicate(timeout=0.1)
except subprocess.TimeoutExpired:
    proc.terminate()
    proc.wait()

print('Exit status', proc.poll())
</code></pre>

<p>It&rsquo;s not available in Python 2, and if you want to reproduce its functionality in Python 2, you actually have to use the <code>select</code> module and poll the input and output file descriptors of the subprocess.
It is a little bit more complicated and it&rsquo;s hard to get right.</p>

<pre><code class="python Stop-gap alternative in Python 2">class Command(object):
    """ Stop-gap alternative for subprocess's timeout in Python 3.
    Based on https://stackoverflow.com/questions/1191374/using-module-subprocess-with-timeout
    """

    def __init__(self, process):
        self.process = process

    def run(self, timeout):
        def target():
            self.process.communicate()

        thread = threading.Thread(target=target)
        thread.start()

        thread.join(timeout)
        if thread.is_alive():
            print 'Terminating process'
            self.process.terminate()
            thread.join()

        print(self.process.returncode)

proc = subprocess.Popen(['sleep', '2'])
command = Command(proc)
command.run(timeout=3)

# NOTE: the following will not work since the subprocess already ran.
# command = Command(proc)
command = Command(subprocess.Popen(['sleep', '2']))
command.run(timeout=1)
</code></pre>

<h3>Item 24: Use threads for blocking I/O, NOT for parallelism</h3>

<p>Python has the GIL, or Global Interpreter Lock.
It means that only one Python thread will ever actually run at a time.
A common mistake is to use threads to speed up a computation-intensive program in Python.
You will be usually disappointed and end up with similar, if not worse, performance.
In other words, you might find that your complicated parallel version will have similar performance as the serial one.</p>

<p>In Python, threads are good for two main use cases.
The first use case is, if you want something looks running simultaneously (concurrency).
A common example is to respond to user inputs while doing network I/O.
In this case, the threads will cooperate with each other to obtain GIL fairly.
The second use case for threads in Python is for IO-intensive applications such as those with lots of (blocking) network, system calls.
A common example is to use threads to query multiple REST endpoints concurrently.
The following example illustrate such use case:</p>

<pre><code class="python Use Python threads for network I/O">import threading
import requests
import time

def get_response(url):
    r = requests.get(url)
    return r.status_code, r.text

class RequestThread(threading.Thread):

    def __init__(self, url):
        super(RequestThread, self).__init__()
        self._url = url

    def run(self):
        self.output = get_response(self._url)

urls = ['https://www.google.com',
        'https://www.facebook.com',
        'https://www.apple.com',
        'https://www.netflix.com',
        'https://www.salesforce.com',
        'https://www.intuit.com',
        'https://www.amazon.com',
        'https://www.uber.com',
        'https://www.lyft.com']

threads = []
for url in urls:
    thread = RequestThread(url)
    thread.start()
    threads.append(thread)

for thread in threads:
    thread.join()
</code></pre>

<p>TODO: Explain GIL and under the cover, <code>request</code> release the control of GIL.</p>

<p>TODO: mistake</p>

<p>TODO: Note about how to call constructor.</p>

<h3>Item 26: Use Queue to cordinate work between threads</h3>

<p>Queue as the blocking queue for threads.</p>

<p>ClosableQueue and Woker classes for building pipelines of workers running in parallel and coordination.</p>

<h3>Item 27: concurrent.futures for true parallelism</h3>

<p><code>ProcessPoolExecutor</code> as the high level API to split work into subprocesses.</p>

<p>Explanation of works behind the scene: lots of serialization and deserialization between main process and child processes.</p>

<p>When to use multiprocessing:</p>

<ul>
<li>Isolated: no data sharing.</li>
<li>High leverage: small input data, large computation.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Python Pt. 4: Using Classes]]></title>
    <link href="http://tdongsi.github.io/python/blog/2018/08/12/effective-python-part-4/"/>
    <updated>2018-08-12T00:19:36-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2018/08/12/effective-python-part-4</id>
    <content type="html"><![CDATA[<p>This post corresponds to Lesson 4 &ldquo;Using Classes&rdquo; of <a href="https://www.safaribooksonline.com/videos/effective-python/9780134175249">&ldquo;Effective Python&rdquo; course</a>.</p>

<!--more-->


<h3>Item 19: Prefer helper classes over book-keeping with dict and tuples</h3>

<p>In an example, the author illustrated the progressive evolution of a grade-book application.
In each iteration, the requirements are changed and interfaces are changed to accomodate that.
Consequently, dictionaries and tuples are added to accomodate those changes in implementation but the logic and code becomes so convoluting with all book-keeping with those built-int data structures.
The final version is shown as follows:</p>

<pre><code class="python Original code with dicts and tuples">class WeightedGradebook(object):
    """
    Change WeightedGradebook to make the score in each subject is weighted.
    For example, final is more weighted than homework.
    """

    def __init__(self):
        self._grade = {}

    def add_student(self, name):
        self._grade[name] = {}

    def report_grade(self, name, subject, score, weight):
        by_subject = self._grade[name]
        grade_list = by_subject.setdefault(subject, [])
        grade_list.append((score, weight))

    def average_grade(self, name):
        by_subject = self._grade[name]
        total, count = 0.0, 0

        for grades in by_subject.values():
            subject_total, subject_weight = 0.0, 0
            for score, weight in grades:
                subject_total = score * weight
                subject_weight = weight

            total += subject_total / subject_weight
            count += 1

        return total / count


def main_weighted():
    book = WeightedGradebook()
    book.add_student('Isaac')

    book.report_grade('Isaac', 'Math', 90, 0.90)
    book.report_grade('Isaac', 'Math', 85, 0.10)
    book.report_grade('Isaac', 'Gym', 95, 0.20)
    book.report_grade('Isaac', 'Gym', 80, 0.20)

    print(book.average_grade('Isaac'))
</code></pre>

<p>As you can see, the <code>average_grade</code> internal implementation is really complicated and hard to understand because of the nested dictionaries.
Externally, the class is not easy to use for clients with four positional arguments: it is easy to mix up the order of arguments, such as weight <code>0.90</code> with score <code>90</code>.</p>

<p>In those cases, it is recommended to unpack dictionaries into separate classes.
Tuples can be unpack into simple classes using <code>namedtuples</code> from <code>collections</code> module.
The line count may be much larger but it is worth it because 1) internally, implementation can be much easier to understand 2) externally, interface can be easier to use.</p>

<pre><code class="python Use helper classes">class Score(object):
    """Weighted score."""

    def __init__(self, score, weight):
        self.score = score
        self.weight = weight

    def weighted_score(self):
        return self.score * self.weight


class Subject(object):
    """Keeping track of weighted scores for a subject"""

    def __init__(self):
        self._grades = []

    def add_score(self, score, weight):
        self._grades.append(Score(score, weight))

    def average_score(self):
        total = sum(e.weighted_score() for e in self._grades)
        weight = sum(e.weight for e in self._grades)
        return total / weight


class Student(object):
    """Keeping track of subjects for a student"""

    def __init__(self):
        self._subjects = defaultdict(Subject)

    def subject(self, name):
        return self._subjects[name]

    def average_grade(self):
        """ Average grade over all subjects"""
        count = len(self._subjects)
        total = sum(e.average_score() for e in self._subjects.values())
        return total / count


class ClassGradebook(object):
    """
    Change WeightedGradebook to make the score in each subject is weighted.
    For example, final is more weighted than homework.
    """

    def __init__(self):
        self._book = defaultdict(Student)

    def student(self, name):
        return self._book[name]

    def report_grade(self, name, subject, score, weight):
        student = self._book[name]
        student.subject(subject).add_score(score, weight)

    def average_grade(self, name):
        student = self._book[name]
        return student.average_grade()

def main_class_2():
    """Helper classes help easier-to-use interface"""
    book = ClassGradebook()

    isaac = book.student('Isaac')
    math = isaac.subject('Math')
    math.add_score(90, 0.90)
    math.add_score(85, 0.10)
    gym = isaac.subject('Gym')
    gym.add_score(95, 0.20)
    gym.add_score(80, 0.20)

    print(isaac.average_grade())
    # Equivalent to the old interface
    print(book.average_grade('Isaac'))
</code></pre>

<h3>Item 20: Use plain attributes instead of getter and setter methods</h3>

<p>For people migrating to Python from Java, they tend to explicit create getter and setter methods for every single attribute in the class.
In Python, it is not recommended and plain attributes should be directly used.</p>

<p>The reason that most people use setters and getters in Java is that in case of changes required for getting or setting an attribute, they can do it easily in corresponding setter or getter method.
In Python, such cases are covered in <code>@property</code> and <code>@setter</code> decorators.</p>

<p>For example, we have the following simple class:</p>

<pre><code class="python Simple class">class Resistor(object):

    def __init__(self, ohms):
        self.ohms = ohms

def main():
    res = Resistor(1e3)
    print(res.ohms)
    res.ohms += 2e3
    print(res.ohms)
</code></pre>

<p>Let&rsquo;s say at some point, we decide that we need special behaviors in getting and setting attribute <code>ohms</code> of Resistor objects.
In that case, we can easily add special behaviors (for example, printing message) as follows:</p>

<pre><code class="python Getter and setter with special behaviors">class Resistor(object):

    def __init__(self, ohms):
        self._ohms = ohms

    @property
    def ohms(self):
        print('Getter')
        return self._ohms

    @ohms.setter
    def ohms(self, value):
        print('Setter')
        self._ohms = value
</code></pre>

<p>The same <code>main()</code> method above will now have the following output:</p>

<pre><code class="plain Before and after output"># Before
1000.0
3000.0

# After
Getter
1000.0
Getter
Setter
Getter
3000.0
</code></pre>

<p>Note that such setter is also effective when the attribute is set in parent constructor, as shown in example below.
This ensures that any validation check in <code>setter</code> method for the attribute is also active at initialization of that object.</p>

<pre><code class="python Setter activated in parent constructor">class Resistor(object):

    def __init__(self, ohms):
        self.ohms = ohms


class LoudResistor(Resistor):

    def __init__(self, ohms):
        super(LoudResistor, self).__init__(ohms)

    @property
    def ohms(self):
        print('Getter')
        return self._ohms

    @ohms.setter
    def ohms(self, value):
        print('Check value')
        self._ohms = value

def main():
    # This will print "Check value"
    # Setter in subclass LoudResistor is activated 
    # although "ohms" attribute is set in superclass Resistor
    res2 = LoudResistor(1e3)
</code></pre>

<p>Tips:</p>

<ul>
<li>Do not modify internal states/attributes or any side effect in getter methods. Only change object&rsquo;s state in setter methods.</li>
<li>Getter method should be fast. Avoid doing complex computations in getter methods.</li>
<li>You can use <code>setter</code> to create unmodifiable objects in Python. See <a href="https://github.com/tdongsi/effective_python">here</a>.</li>
</ul>


<h3>Item 21: Prefer internal attributes over private ones</h3>

<p>In Python, there are only two types of attribute: public (e.g., <code>my_att</code>) and private attributes (e.g., <code>__my_att</code>).
In reality, there is no tight access control like other languages such as Jaza.
The private attribute names are prefixed with the class name (e.g., <code>_MyClass__my_att</code>) to create another &ldquo;namespace&rdquo; for private attributes.
This will complicate accessing the private attributes in the subclasses while not effectively preventing anyone from accessing the private attributes when the need arises.
In general, it is better to use protected/&ldquo;internal&rdquo; attributes <code>_my_att</code> with the assumption that someone can extend usage of those internal attributes later on.</p>

<p>The scenario where you should use private attributes is when you want to avoid accidental name clash in the subclass.</p>

<pre><code class="python Scenario for using private attribute">class ApiClass(object):

    def __init__(self):
        self._value = 5

    def get(self):
        return self._value


class Child(ApiClass):

    def __init__(self):
        super(Child, self).__init__()

        # Here, Child class author is not aware of
        # internal implementation of ApiClass
        # he accidentally override an internal attribute of ApiClass
        self._value = 'hello'

a = Child()
print(a.get())
</code></pre>

<p>In this case, <code>_value</code> in ApiClass should be a private attribute.</p>

<h3>Item 22: Use <code>@classmethod</code> polymorphism to construct objects generically</h3>

<p>In other languages such as Java, you can have overloaded constructors to construct objects of the same class/interface in different ways.
However, in Python, the method <code>__init__</code> can&rsquo;t be overloaded.
Instead, you can use <code>@classmethod</code> polymorphism to construct objects generically.</p>

<pre><code class="python Example of @classmethod polymorphism">import os
from threading import Thread


class InputData(object):
    def read(self):
        raise NotImplementedError

    @classmethod
    def generate_inputs(cls, config):
        raise NotImplementedError


class PathInputData(InputData):

    def __init__(self, path):
        self.path = path

    def read(self):
        with open(self.path, 'rb') as handle:
            return handle.read()

    @classmethod
    def generate_inputs(cls, config):
        """ Generic version of generate_inputs"""
        data_dir = config['data_dir']
        for name in os.listdir(data_dir):
            yield cls(os.path.join(data_dir, name))


def generate_inputs(data_dir):
    """ Original version of generate_inputs"""
    for name in os.listdir(data_dir):
        yield PathInputData(os.path.join(data_dir, name))


class Worker(object):
    def __init__(self, input_data):
        self.input_data = input_data
        self.result = None

    def map(self):
        raise NotImplementedError

    def reduce(self):
        raise NotImplementedError

    @classmethod
    def create_workers(cls, input_class, config):
        """ Generic version of create_worker.

        :param input_class: class that implements InputData interface.
        :param config: dictionary of configs to be used by InputData.
        :return:
        """
        workers = []
        for input_data in input_class.generate_inputs(config):
            workers.append(cls(input_data))
        return workers


def create_worker(input_list):
    """ Original version of create_worker"""
    workers = []
    for input_data in input_list:
        workers.append(LineCounter(input_data))
    return workers


class LineCounter(Worker):
    def map(self):
        data = self.input_data.read()
        self.result = data.count(b'\n')
        pass

    def reduce(self, other):
        self.result += other.result
        pass


def execute(workers):
    threads = [Thread(target=w.map) for w in workers]

    for t in threads:
        t.start()
    for t in threads:
        t.join()

    first, rest = workers[0], workers[1:]
    for other in rest:
        first.reduce(other)
    return first.result


def mapreduce(data_dir):
    inputs = generate_inputs(data_dir)
    workers = create_worker(inputs)
    return execute(workers)


def mapreduce_generic(worker_class, input_class, config):
    workers = worker_class.create_workers(input_class, config)
    return execute(workers)


import random
from backports.tempfile import TemporaryDirectory


def write_test_files(temp_dir):
    for i in range(100):
        with open(os.path.join(temp_dir, str(i)), 'w') as handle:
            handle.write('\n' * random.randint(0, 100))


with TemporaryDirectory() as temp_dir:
    write_test_files(temp_dir)
    # line_count = mapreduce(temp_dir)

    config = {'data_dir': temp_dir}
    line_count = mapreduce_generic(LineCounter, PathInputData, config)
    print line_count
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Python Pt. 3: Functions]]></title>
    <link href="http://tdongsi.github.io/python/blog/2018/08/12/effective-python-part-3/"/>
    <updated>2018-08-12T00:19:32-07:00</updated>
    <id>http://tdongsi.github.io/python/blog/2018/08/12/effective-python-part-3</id>
    <content type="html"><![CDATA[<p>This post corresponds to Lesson 3 &ldquo;Using Functions&rdquo; of <a href="https://www.safaribooksonline.com/videos/effective-python/9780134175249">&ldquo;Effective Python&rdquo; course</a>.</p>

<!--more-->


<h3>Item 13: Know how closures interact with variable scope</h3>

<p>For this item&rsquo;s discussion, let&rsquo;s say that we have a list of integers that needs to be sorted, with the twist that some of those integers are in a special group (higher prirority) and has to be placed in front of the list (referred as <strong>Problem-1</strong>).
For example, those integers could be IDs of different UI components, with those of higher priority belong to the foreground and the rest are in the background.
One solution to this problem is as follows:</p>

<pre><code class="python Solution to Problem-1">NUMBERS = [8, 3, 1, 2, 5, 4, 7, 6]
GROUP = {2, 3, 5, 7}

def sort_priority(numbers, group):
    """ Sort the input numbers but put those in "group" first.

    :param numbers: list of input numbers.
    :param group: set of numbers in priority group.
    """

    def helper(x):
        if x in group:
            return (0, x)
        return (1, x)

    numbers.sort(key=helper)
    pass

def main_original():
    numbers = NUMBERS[:]
    print(sort_priority(numbers, GROUP))
    print(numbers)
</code></pre>

<p>Now, the <strong>additional requirement</strong> is that we want to know if any item in the input list belongs to the special <code>GROUP</code> (now referred as <strong>Problem-2</strong>).
To accommodate this new requirement, one can naively modify Problem-1&rsquo;s solution as follows:</p>

<pre><code class="python Naive solution to Problem-2">def sort_priority(numbers, group):
    """ Sort the input numbers but put those in "group" first.

    :param numbers: list of input numbers.
    :param group: set of numbers in priority group.
    :return: True if any number in priority is found.
    """
    found = False

    def helper(x):
        if x in group:
            found = True
            return (0, x)
        return (1, x)

    numbers.sort(key=helper)
    return found
</code></pre>

<p>In this naive (and incorrect) solution, an additional variable <code>found</code> is used to track if any element in the input list <code>numbers</code> is special and set accordingly.
However, this solution proves not working as expected: the above <code>sort_priority</code> method always returns <code>False</code>, regardless of the input list of numbers.</p>

<p>The reason for this is a common mistake of Python users when using the same variable in different scopes.
In this example, <code>found</code> is found in two different scopes: in the enclosed <code>helper</code> method and in the enclosing <code>sort_priority</code> method.
In most cases, when we simply refer to a variable (i.e., read operation), Python will do its best to look up for that variable in different scopes, as shown below.</p>

<pre><code class="python Variable reference in different scopes.">meep = 23

def enclosing():
    """ Variable reference in different scopes.
    """
    foo = 15

    def my_func():
        bar = 10

        print(bar)      # local scope
        print(foo)      # enclosing scope
        print(meep)     # global scope
        print(str)      # built-in scope
        # print(not_exist)  # not found in any scopes

    my_func()

enclosing()

# Output:
# 10
# 15
# 23
# &lt;type 'str'&gt;
</code></pre>

<p>However, variable assignment has a slightly different treatment.
When we try to assign to a variable for the first time in the inner scope, Python will create a new local variable.
This will lead to subtle difference if we have variable assignment in the inner scope, as shown in the following example.</p>

<pre><code class="python Variable assignment in different scopes.">def enclosing_assignment():
    """ Variable assignment in different scopes.
    """

    foo = 15
    foo = 25

    def my_func():
        foo = 15
        bar = 5

        print(foo)
        print(bar)

    my_func()
    print(foo)

enclosing_assignment()

# Output:
# 15
# 5
# 25
</code></pre>

<p>Going back to our Problem-2, the problem of our naive solution is that we have assignment to the variable <code>found</code> in the inner scope.
Python will create a new variable in <code>helper</code>&rsquo;s scope and ignore the variable <code>found</code> already defined in the outer scope <code>sort_priority</code>.
After <code>helper</code> method is done, <code>found</code> in <code>sort_priority</code> scope still has the original value <code>False</code> and it is what the method returns.</p>

<p>There are many ways to work around the scope problem with variable assignment described above.
In Python 3, <code>nonlocal</code> keyword is introduced exactly for this situation.
The keyword <code>nonlocal</code>, similar to <code>global</code> keyword, allows you to assign to variables in outer, but non-global, scope.</p>

<pre><code class="python Using nonlocal keyword for Problem-2">def sort_priority_python_3(numbers, group):
    """ Sort the input numbers but put those in "group" first."""
    found = False

    def helper(x):
        if x in group:
            nonlocal found
            found = True
            return (0, x)
        return (1, x)

    numbers.sort(key=helper)
    return found
</code></pre>

<p>However, using <code>nonlocal</code> keyword can be confusing and is generally not recommended, especially if the variable is declared a couple of scopes/layers away from the assignment.
In addition, such approach would not work in Python 2.
In another approach that would work for both Python 2 and 3, one can use the following trick:</p>

<pre><code class="python Using array for Problem-2">def sort_priority_python_2(numbers, group):
    """ Sort the input numbers but put those in "group" first."""
    found = [False]

    def helper(x):
        if x in group:
            found[0] = True
            return (0, x)
        return (1, x)

    numbers.sort(key=helper)
    return found[0]
</code></pre>

<p>In this trick, instead of using a boolean variable <code>found</code>, you use a singleton (one-element) array <code>found</code>.
Because <code>found</code> is now an array, the variable reference rules, instead of variable assignment rules, apply and the <code>found</code> variable in the outer scope is used.
Although it is a great trick, such code is not really clear.</p>

<p>The final and recommended solution is to extract the <code>helper</code> function into a CheckSpecial class instead.
The original <code>helper</code> method used for <strong>Problem-1</strong> can be converted to a Helper/CheckSpecial class as follows:</p>

<pre><code class="python Using CheckSpecial class for Problem-1">class CheckSpecial(object):

    def __init__(self, group):
        self.group = group

    def __call__(self, x):
        if x in self.group:
            return (0, x)
        return (1, x)

def sort_priority_solved(numbers, group):
    helper = CheckSpecial(GROUP)
    numbers.sort(key=helper)
</code></pre>

<p>In the solution to starting <strong>Problem-1</strong> shown above, the origial <code>helper</code> function&rsquo;s logic has been encapsulated into a CheckSpecial class, in the <code>__call__</code> method specifically.
When the additional requirement &ldquo;check if special number encountered&rdquo; comes in, it is apparent that <code>helper</code> function has to become a stateful closure.
Since we already has it converted to <code>CheckSpecial</code> class, it would be easier to keep the state as a new <code>CheckSpecial</code> object&rsquo;s attribute <code>found</code> and update the object state accordingly, as follows:</p>

<pre><code class="python Updating CheckSpecial class for Problem-2">class CheckSpecial(object):

    def __init__(self, group):
        self.group = group
        self.found = False

    def __call__(self, x):
        if x in self.group:
            self.found = True
            return (0, x)
        return (1, x)

def sort_priority_solved(numbers, group):
    helper = CheckSpecial(GROUP)
    numbers.sort(key=helper)
    return helper.found
</code></pre>

<p>IMHO, this approach is much clearer and works for both Python 2 and 3.</p>

<h3>Item 14: Accept callables for stateful closures</h3>

<p>Many of Python APIs allow you to customize behavior by passing in a function, such as <code>sort(key=...)</code> method in the last section &ldquo;Item 13&rdquo;.
We also see that it is possible to pass stateful closure as a function into those hooks for record-keeping purposes, for example.
We showed different ways to do that in Python 2 and 3: <code>nonlocal</code> keyword, <code>list</code> trick, and a helper class.
Using a class to encapsulate a stateful closure is the highly recommended approach.</p>

<pre><code class="python Another version of CheckSpecial class for Problem-2">class CheckSpecial(object):

    def __init__(self, group):
        self.group = group
        self.found = False

    def check(self, x):
        if x in self.group:
            self.found = True
            return (0, x)
        return (1, x)

def sort_priority_solved(numbers, group):
    helper = CheckSpecial(GROUP)
    numbers.sort(key=helper.check)
    return helper.found
</code></pre>

<p>Let us consider an alternative version of CheckSpecial class where we use standard method name <code>check</code> instead of special method <code>__call__</code>.
And it works perfectly fine if you pass <code>helper.check</code> as a function: <code>sort</code> has no idea that we are passing a method of a stateful object and it does not care.</p>

<p>However, for programmers new to the code, the <code>CheckSpecial</code> class is really awkward: it is not clear the purpose of the class in isolation and that its instances are never to be created and used alone.
Instead, in the last section, we intentionally use <code>__call__</code> method to make each CheckSpecial instance a stateful &ldquo;callable&rdquo;.
In that way, the intention of the class is clearer: it is a stateful closure that is meant to be passed into the hook of another function (e.g., <code>sort</code>, <code>defaultdict</code>).</p>

<h3>Item 15: Reduce visual noise with variable positional arguments</h3>

<pre><code class="python Example of variable position arguments">def log(message, *args):
    pass

log('Check', 1, 2, 3)
args = [1, 2, 3]
log('Check', *args)
</code></pre>

<p>Two things to watch for when using variable positional arguments:</p>

<ul>
<li>If a generator is passed in, the generator will be exhausted as the arguments.</li>
<li>When you change the signature/behavior of the method such as adding new argument in front, it can misbehave quietly.</li>
</ul>


<h3>Item 16: Provide optional behavior with keyword arguments</h3>

<p>Positional arguments come before keyword arguments.
You can&rsquo;t pass positional arguments after keyword argyment.</p>

<p>The flexibility of keyword arguments provides three significant benefits:</p>

<ol>
<li>Functional calls are more clear.</li>
<li>Default arguments defined in function definitions.</li>
<li>Allow extending a function&rsquo;s parameters while it is still backward compatible.</li>
</ol>


<h3>Item 17: Enforce clarity with keyword-only arguments</h3>

<p>In Python 3, you can specify <code>*</code> in the function&rsquo;s argument list.</p>

<pre><code class="plain Keyword-only parameters">&gt;&gt;&gt; def foo(pos, *, forcenamed):
...   print(pos, forcenamed)
... 
&gt;&gt;&gt; foo(pos=10, forcenamed=20)
10 20
&gt;&gt;&gt; foo(10, forcenamed=20)
10 20
&gt;&gt;&gt; foo(10, 20)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo() takes exactly 1 positional argument (2 given)
</code></pre>

<p>This can also be combined with <code>**kwargs</code>:</p>

<pre><code class="python">def foo(pos, *, forcenamed, **kwargs):
</code></pre>

<p>In Python 2, the alternative is to <code>pop</code> the <code>**kwargs</code> with default values.
However, that requires docstring to explain what parameters (keys) are expected in <code>kwargs</code> and you lose signature information in your smart editor.</p>

<p>Another alternative in Python 2 is to use a dummy keyword argument to limit number of positional argument.</p>

<pre><code class="python ">_dummy = object()

def foo(pos, _kw=_dummy, forcenamed):
    if _kw is not _dummy:
        raise TypeError("foo() takes 1 positional argument (at least 2 given)")
</code></pre>

<p>This will allow:</p>

<pre><code class="python Examples"># Allowed
foo(bar)        
foo(bar, collapse=0)        
foo(spacing=15, pos=bar)

# But not allowed
foo(bar, 12)
</code></pre>

<p>See <a href="https://stackoverflow.com/questions/2965271/forced-naming-of-parameters-in-python">here</a> for more discussions.</p>
]]></content>
  </entry>
  
</feed>
